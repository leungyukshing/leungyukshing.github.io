---
title: 俄罗斯方块
tags:
  - CCF
abbrlink: 11121
date: 2018-03-15 00:12:02
---
## 俄罗斯方块问题
### 问题描述
&emsp;俄罗斯方块是俄罗斯人阿列克谢·帕基特诺夫发明的一款休闲游戏。
&emsp;游戏在一个15行10列的方格图上进行，方格图上的每一个格子可能已经放置了方块，或者没有放置方块。每一轮，都会有一个新的由4个小方块组成的板块从方格图的上方落下，玩家可以操作板块左右移动放到合适的位置，当板块中某一个方块的下边缘与方格图上的方块上边缘重合或者达到下边界时，板块不再移动，如果此时方格图的某一行全放满了方块，则该行被消除并得分。
&emsp;在这个问题中，你需要写一个程序来模拟板块下落，你不需要处理玩家的操作，也不需要处理消行和得分。
&emsp;具体的，给定一个初始的方格图，以及一个板块的形状和它下落的初始位置，你要给出最终的方格图。
<!-- more -->

### 输入格式
&emsp;输入的前15行包含初始的方格图，每行包含10个数字，相邻的数字用空格分隔。如果一个数字是0，表示对应的方格中没有方块，如果数字是1，则表示初始的时候有方块。输入保证前4行中的数字都是0。
&emsp;输入的第16至第19行包含新加入的板块的形状，每行包含4个数字，组成了板块图案，同样0表示没方块，1表示有方块。输入保证板块的图案中正好包含4个方块，且4个方块是连在一起的（准确的说，4个方块是四连通的，即给定的板块是俄罗斯方块的标准板块）。
&emsp;第20行包含一个1到7之间的整数，表示板块图案最左边开始的时候是在方格图的哪一列中。注意，这里的板块图案指的是16至19行所输入的板块图案，如果板块图案的最左边一列全是0，则它的左边和实际所表示的板块的左边是不一致的（见样例）

### 输出格式
&emsp;输出15行，每行10个数字，相邻的数字之间用一个空格分隔，表示板块下落后的方格图。注意，你不需要处理最终的消行。

### 样例输入
> 0 0 0 0 0 0 0 0 0 0
> 0 0 0 0 0 0 0 0 0 0
> 0 0 0 0 0 0 0 0 0 0
> 0 0 0 0 0 0 0 0 0 0
> 0 0 0 0 0 0 0 0 0 0
> 0 0 0 0 0 0 0 0 0 0
> 0 0 0 0 0 0 0 0 0 0
> 0 0 0 0 0 0 0 0 0 0
> 0 0 0 0 0 0 0 0 0 0
> 0 0 0 0 0 0 0 0 0 0
> 0 0 0 0 0 0 0 1 0 0
> 0 0 0 0 0 0 1 0 0 0
> 0 0 0 0 0 0 1 0 0 0
> 1 1 1 0 0 0 1 1 1 1
> 0 0 0 0 1 0 0 0 0 0
> 0 0 0 0
> 0 1 1 1
> 0 0 0 1
> 0 0 0 0
> 3

### 样例输出
> 0 0 0 0 0 0 0 0 0 0
> 0 0 0 0 0 0 0 0 0 0
> 0 0 0 0 0 0 0 0 0 0
> 0 0 0 0 0 0 0 0 0 0
> 0 0 0 0 0 0 0 0 0 0
> 0 0 0 0 0 0 0 0 0 0
> 0 0 0 0 0 0 0 0 0 0
> 0 0 0 0 0 0 0 0 0 0
> 0 0 0 0 0 0 0 0 0 0
> 0 0 0 0 0 0 0 0 0 0
> 0 0 0 0 0 0 0 1 0 0
> 0 0 0 0 0 0 1 0 0 0
> 0 0 0 0 0 0 1 0 0 0
> 1 1 1 1 1 1 1 1 1 1
> 0 0 0 0 1 1 0 0 0 0

## 解决方法
### 分析
&emsp;对于游戏的方格图，我们很容易想到使用一个二维数组来进行储存。对于新增加的方块，这里我采用了自定义的方式，对其的横纵坐标进行了保存，注意是对每个小方块在4\*4矩阵中的位置进行保存。
&emsp;解决了存储数据的问题后，我们来解决下落的问题，首先要利用题目给的偏移量，即第20行的数据，对方块整体的位置进行调整。由于我们对新增方块的保存是基于4\*4矩阵的相对位置，因此，只需要对每一个小方块的横坐标加上偏移量即可。在模拟下落过程时，声明一个**drop_dis**变量表示下落的距离，先对每一个小方块的下一格是否为空进行判断，若方块整体都可以移动，则下落距离**drop_dis**加1，直到不能再下落，就在方格图中进行填充。

### 代码实现
```C++
#include <iostream>
using namespace std;

struct Point {
  int x;
  int y;
  Point() {
    x = y = 0;
  }
  Point(int _x, int _y) {
    x = _x;
    y = _y;
  }
};

int main() {
  int map[15][10];
  Point add_on[4];
  int count = 0;
  for (int i = 0; i < 15; i++) {
    for (int j = 0; j < 10; j++) {
      cin >> map[i][j];
    }
  }

  for (int i = 0; i < 4; i++) {
    for (int j = 0; j < 4; j++) {
      int tmp;
      cin >> tmp;
      if (tmp == 1) {
        add_on[count].x = i;
        add_on[count].y = j;
        count++;
      }
    }
  }

  int diff;
  cin >> diff;
  for (int i = 0; i < 4; i++) {
    add_on[i].y += (diff - 1);
  }

  bool flag = true;
  int drop_dis = 0;
  count = 0;
  while (flag == true) {
    for (int i = 0; i < 4; i++) {
      if (map[add_on[i].x + drop_dis + 1][add_on[i].y] == 0) {
        count++;
      }
    }

    if (count == 4) {
      drop_dis++;
      count = 0;
    }
    else {
      // 填充
      for (int i = 0; i < 4; i++) {
        map[add_on[i].x + drop_dis][add_on[i].y] = 1;
      }
      flag = false;
    }
  }

  for (int i = 0 ; i < 15; i++) {
    for (int j = 0; j < 9; j++) {
      cout << map[i][j] << " ";
    }
    cout << map[i][9] << endl;
  }

  return 0;
}
```

本题的讲解到这里结束了，谢谢！
